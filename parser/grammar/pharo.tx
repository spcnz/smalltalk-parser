Program:
    ws? temps=Temps? ws? statements *= Statement
    ;

Temps :
     PIPE (ws? vars=ID)+ ws? PIPE
   ;
Statement :
    ReturnStatement ws?
    | Expressions ws? PERIOD ws? ReturnStatement
    | Expressions PERIOD? ws?
;
ReturnStatement:
    '^' ws? return = Expression ws? PERIOD?
;
Expressions:
    exp=Expression (ws? PERIOD ws? list=Expression)*
;

Expression:
      assignment=Assignment
    | cascade=Cascade
    | send=BinarySend
    | send=UnarySend
    | literal = Literal
;

Assignment :
    var = ID ws? ':=' ws? value = Expression
;

Cascade:
    BinarySend (ws? ';' ws? Message)+
;

Message:
    UnaryMessage
    | BinaryMessage
;

BinarySend:
    (receiver=UnarySend | receiver=Receiver) ws? tail=BinaryTail
;

UnarySend:
    receiver=Receiver ws? selector=UnaryTail
;

UnaryTail:
    msg=UnaryMessage ws? tail=UnaryTail? ws?
;

UnaryMessage:
    ws? unarySelector=ID
;

BinaryTail : msg=BinaryMessage tail=BinaryTail?;

BinaryMessage:
    ws? selector=BINARY_SELECTOR ws? (arg=UnarySend | arg=Literal)
;


Receiver:
	Literal
	| Subexpression
	|	ID
;

Subexpression :
    '(' ws? Expression ws? ')'
;

Selector:
	ID
;
Argument:
    Literal
;

CommentPharo:
   /"(.|[\r\n])*?"/
;

Literal :
    	NUMBER
	|	STRING
	|   NIL
    |   SELF
    |   BOOL
    |   SUPER
;

ws : (SEPARATOR | CommentPharo)+;

SELF   : 'self' ;
SUPER  : 'super' ;
NIL    : 'nil' ;
PERIOD : '.';
SEPARATOR : /[ \t\r\n]/;
PIPE : '|' ;

BINARY_SELECTOR :
     '+'
    | '*' 
    | '//' 
    | '=' 
    | '>' 
    | '<' 
    | ',' 
    | '@' 
    | '%' 
    | '~' 
    | PIPE 
    | '&' 
    | '-'
    | '/'
    | '\\'
    ;

